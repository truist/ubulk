#!/bin/sh

# die on error (except in functions and various other circumstances)
# (we should be manually handling all possible errors, so this is "just in case")
set -e

usage() {
	EXITCODE=$1
	cat << EOF >&2
usage: ${0##*/} [-C /path/to/ubulk.conf]"
                   [-c (yes|no)] [-p (yes|no)]"
                   [-hv]"
       -c (yes|no) Whether to run pkg_chk before building"
       -h          This help"
       -p (yes|no) Whether to update pkgsrc before building"
       -s (yes|no) Whether to create and mount a sandbox before building"
       -v          Turn on verbose mode"
EOF
	exit ${1:-1}
}

# a trick to delay setting variables based on the command-line args, so they
# can trump the defaults and the config file, later
stashArg() {
	ARG_STASH="$ARG_STASH $1=\"${OPTARG}\" ;"
}

while getopts C:c:hp:s:v opt; do
    case $opt in
		C)  ARG_CONFIG="${OPTARG}" ;; # this one needs special handling
		c)  stashArg "DOPKGCHK" ;;
		h)  usage 0 ;;
		p)  stashArg "DOPKGSRC" ;;
		s)  stashArg "DOSANDBOX" ;;
		v)  set -x ;;
		\?) usage ;;
    esac
done
shift $(expr $OPTIND - 1)
if [ $# != 0 ]; then usage; fi

#-------------------------------------------------------------------------
### UTILITY FUNCTIONS ###

# these can't be in util.sh because we need them to find util.sh
check_for_relative_path() {
	echo "$1" | grep "^[^/]" >/dev/null 2>&1
	echo $?
}

find_script_real_dir() {
	set -e
	if [ -n "$BASH_SOURCE" ]; then
		SOURCE="${BASH_SOURCE}"
	else
		SOURCE="$0"
	fi
	while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		SOURCE="$(readlink "$SOURCE")"
		if [ $(check_for_relative_path $SOURCE) -eq 0 ]; then
			# if $SOURCE was a relative symlink, we need to resolve it relative to the
			# path where the symlink file was located
			SOURCE="$DIR/$SOURCE"
		fi
	done
	echo "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
}


#-------------------------------------------------------------------------
### SETTINGS AND SETUP ###

SCRIPT_DIR=$(find_script_real_dir)
LIB_DIR="$SCRIPT_DIR/lib"

# load the defaults
. "$LIB_DIR/defaults.conf"

# process a command-line-specified CONFIG
if [ -n "$ARG_CONFIG" ]; then
	if [ $(check_for_relative_path $ARG_CONFIG) -eq 0 ]; then
		ARG_CONFIG="$(pwd)/$ARG_CONFIG"
	fi
	if [ ! -f "$ARG_CONFIG" ]; then
		echo >&2 "ERROR: Specified config file '$ARG_CONFIG' not found"
		exit 1
	fi
	CONFIG="$ARG_CONFIG"
fi

# load the config file
if [ -f "$CONFIG" ]; then
	. "$CONFIG"
fi

# override with the command-line args
eval "$ARG_STASH"

# load the utility functions (now that we know where the log should go)
LOGPATH=${BUILDLOG:?} . "$LIB_DIR/util.sh"
# from here forward we have to use 'console' and 'die' to get output
# to the console


#-------------------------------------------------------------------------
### START DOING ACTUAL WORK ###

# update pkgsrc
if [ "yes" = "$DOPKGSRC" ]; then
	console "Updating pkgsrc ($PKGSRC)"
	# in a subshell, to preserve pwd
	(cd "$PKGSRC" && git pull) || die $?
else
	console "Skipping pkgsrc update"
fi

# run pkg_chk
if [ "yes" = "$DOPKGCHK" ]; then
	console "Checking for missing, out-of-date, or extra packages"
	if command -v $PKGCHK >/dev/null 2>&1 ; then
		CHKRESULTS=$($PKGCHK -a -u -r -q -B -C $PKGLIST) || die $?
		if [ "" = "$CHKRESULTS" ]; then
			console_err "$PKGCHK says everything is in sync, exiting"
			exit 0
		else
			console "$(echo "$CHKRESULTS" | sed 's/^/  /')" || die $?
		fi
	else
		console "Can't find $PKGCHK; skipping"
	fi
else
	console "Skipping $PKGCHK"
fi

if [ "yes" = "$DOSANDBOX" ]; then
	console "Mounting sandbox ($SANDBOXDIR)"
	if echo "$SANDBOXDIR" | grep "^[^/].*" >/dev/null 2>&1 ; then
		console_err "SANDBOXDIR must be an absolute path ($SANDBOXDIR)"
		exit 1
	fi
	if command -v "$MKSANDBOX" >/dev/null 2>&1 ; then
		"$MKSANDBOX" $MKSANDBOXARGS "$SANDBOXDIR" || die $?
	else
		console_err "Can't find $MKSANDBOX, please install it and/or set MKSANDBOX"
		exit 1
	fi
else
	console "Skipping sandbox creation"
fi


console
console "Done!"

