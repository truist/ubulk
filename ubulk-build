#!/bin/sh

# die on error (except in functions and various other circumstances)
# (we should be manually handling all possible errors, so this is "just in case")
set -e

usage() {
	EXITCODE=$1
	echo >&2 "usage: ${0##*/} [-C /path/to/ubulk.conf]"
	echo >&2 "                   [-c (yes|no)] [-p (yes|no)]"
	echo >&2 "                   [-hv]"
	echo >&2 "       -c (yes|no) Whether to run pkg_chk before building"
	echo >&2 "       -h          This help"
	echo >&2 "       -p (yes|no) Whether to update pkgsrc before building"
	echo >&2 "       -v          Turn on verbose mode"
	exit ${1:-1}
}

# a trick to delay setting variables based on the command-line args, so they
# can trump the defaults and the config file, later
stashArg() {
	ARG_STASH="$ARG_STASH $1=\"${OPTARG}\" ;"
}

while getopts C:c:hp:v opt; do
    case $opt in
		C)  ARG_CONFIG="${OPTARG}" ;; # this one needs special handling
		c)  stashArg "DOPKGCHK" ;;
		h)  usage 0 ;;
		p)  stashArg "UPDATEPKGSRC" ;;
		v)  set -x ;;
		\?) usage ;;
    esac
done
shift $(expr $OPTIND - 1)
if [ $# != 0 ]; then usage; fi

#-------------------------------------------------------------------------
### UTILITY FUNCTIONS ###

# these can't be in util.sh because we need them to find util.sh
check_for_relative_path() {
	echo "$1" | grep "^[^/]" >/dev/null 2>&1
	echo $?
}

find_script_real_dir() {
	set -e
	if [ -n "$BASH_SOURCE" ]; then
		SOURCE="${BASH_SOURCE}"
	else
		SOURCE="$0"
	fi
	while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		SOURCE="$(readlink "$SOURCE")"
		if [ $(check_for_relative_path $SOURCE) -eq 0 ]; then
			# if $SOURCE was a relative symlink, we need to resolve it relative to the
			# path where the symlink file was located
			SOURCE="$DIR/$SOURCE"
		fi
	done
	echo "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
}


#-------------------------------------------------------------------------
### SETTINGS AND SETUP ###

SCRIPT_DIR=$(find_script_real_dir)
LIB_DIR="$SCRIPT_DIR/lib"

# load the defaults
. "$LIB_DIR/defaults.conf"

# process a command-line-specified CONFIG
if [ -n "$ARG_CONFIG" ]; then
	if [ $(check_for_relative_path $ARG_CONFIG) -eq 0 ]; then
		ARG_CONFIG="$(pwd)/$ARG_CONFIG"
	fi
	if [ ! -f "$ARG_CONFIG" ]; then
		echo >&2 "ERROR: Specified config file '$ARG_CONFIG' not found"
		exit 1
	fi
	CONFIG="$ARG_CONFIG"
fi

# load the config file
if [ -f "$CONFIG" ]; then
	. "$CONFIG"
fi

# override with the command-line args
eval "$ARG_STASH"

# load the utility functions (now that we know where the log should go)
LOGPATH=${BUILDLOG:?} . "$LIB_DIR/util.sh"
# from here forward we have to use 'console' and 'die' to get output
# to the console


#-------------------------------------------------------------------------
### START DOING ACTUAL WORK ###

# update pkgsrc
if [ "yes" = "$UPDATEPKGSRC" ]; then
	console "Updating pkgsrc ($PKGSRC)"
	cd "$PKGSRC" && git pull || die $?
else
	console "Skipping pkgsrc update"
fi

# run pkg_chk
if [ "yes" = "$DOPKGCHK" ]; then
	console "Checking for missing, out-of-date, or extra packages"
	if command -V pkg_chk >/dev/null 2>&1 ; then
		CHKRESULTS=$(pkg_chk -a -u -r -q -B -C /etc/pkglist) || die $?
		if [ "" = "$CHKRESULTS" ]; then
			console_err "pkg_chk says everything is in sync, exiting"
			exit 0
		else
			console "$(echo "$CHKRESULTS" | sed 's/^/  /')" || die $?
		fi
	else
		console "Can't find pkg_chk; skipping"
	fi
else
	console "Skipping pkg_chk"
fi


console
console "Done!"

