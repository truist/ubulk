#!/bin/sh

# die on error (except in functions and various other circumstances)
# (we should be manually handling all possible errors, so this is "just in case")
set -e

usage() {
	EXITCODE=$1
	echo >&2 "usage: ${0##*/} [-C /path/to/ubulk.conf]"
	echo >&2 "                   [-c (yes|no)] [-p (yes|no)]"
	echo >&2 "                   [-hv]"
	echo >&2 "       -c (yes|no) Whether to run pkg_chk before building"
	echo >&2 "       -h          This help"
	echo >&2 "       -p (yes|no) Whether to update pkgsrc before building"
	echo >&2 "       -v          Turn on verbose mode"
	exit ${1:-1}
}

# process the arguments
while getopts C:c:hp:v opt; do
    case $opt in
		C)  CONFIG="${OPTARG}"; CONFIG_SET=yes ;;
		c)  DOPKGCHK="${OPTARG}" ;;
		h)  usage 0 ;;
		p)  UPDATEPKGSRC="${OPTARG}" ;;
		v)  set -x ;;
		\?) usage ;;
    esac
done
shift $(expr $OPTIND - 1)
if [ $# != 0 ]; then usage; fi


### UTILITY FUNCTIONS ###
# these can't be in util.sh because we need them to find util.sh
check_for_relative_path() {
	echo "$1" | grep -q "^[^/]" >/dev/null 2>&1
	echo $?
}

find_script_real_dir() {
	set -e
	if [ -n "$BASH_SOURCE" ]; then
		SOURCE="${BASH_SOURCE}"
	else
		SOURCE="$0"
	fi
	while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		SOURCE="$(readlink "$SOURCE")"
		if [ $(check_for_relative_path $SOURCE) -eq 0 ]; then
			# if $SOURCE was a relative symlink, we need to resolve it relative to the
			# path where the symlink file was located
			SOURCE="$DIR/$SOURCE"
		fi
	done
	echo "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
}
### END UTILITY FUNCTIONS ###


### SETTINGS AND SETUP ###
SCRIPT_DIR=$(find_script_real_dir)
LIB_DIR="$SCRIPT_DIR/lib"

# load the defaults
. "$LIB_DIR/defaults.conf"

# load the config file
if [ $(check_for_relative_path $CONFIG) -eq 0 ]; then
	CONFIG="$(pwd)/$CONFIG"
fi
if [ -f "$CONFIG" ]; then
	. "$CONFIG"
elif [ -n "$CONFIG_SET" ]; then
	echo >&2 "ERROR: Specified config file '$CONFIG' not found"
	exit 1
fi

# load the utility functions (after we know where the log should go)
LOGPATH=${BUILDLOG:?} . "$LIB_DIR/util.sh"
# from here forward we have to use 'console' and 'die' to get output
# to the console
### END SETTINGS AND SETUP ###


### START DOING ACTUAL WORK ###

# update pkgsrc
echo $UPDATEPKGSRC
if [ "yes" = "$UPDATEPKGSRC" ]; then
	console "Updating pkgsrc ($PKGSRC)"
	cd "$PKGSRC" && git pull || die $?
else
	console "Skipping pkgsrc update"
fi

# run pkg_chk
echo $DOPKGCHK
if [ "yes" = "$DOPKGCHK" ]; then
	console "Checking for missing, out-of-date, or extra packages"
	if command -V pkg_chk >/dev/null 2>&1 ; then
		CHKRESULTS=$(pkg_chk -a -u -r -q -B -C /etc/pkglist) || die $?
		if [ "" = "$CHKRESULTS" ]; then
			console_err "pkg_chk says everything is in sync, exiting"
			exit 0
		else
			console "$(echo "$CHKRESULTS" | sed 's/^/  /')" || die $?
		fi
	else
		console "Can't find pkg_chk; skipping"
	fi
else
	console "Skipping pkg_chk"
fi


console
console "Done!"

